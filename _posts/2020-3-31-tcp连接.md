---
layout:	 post
title:	"tcp连接"
subtitle: ""
date: 2020-3-31
author: "roger"
head-img: "img/post-bg-js-module.jpg"
tags:
    - 计网
---

## TCP三次握手

第一步：客户机端的TCP首先向服务器端的TCP发送SYN报文段。该报文段中不包含应用层数据，但是报文段的首部中的一个标志位（SYN比特）被置为1。另外，客户机会选择一个起始序号（client_isn）,并将其放在TCP SYN报文段的序号字段中。合适的选择client_isn可以避免某些安全性攻击

第二步：一旦包含TCP SYN报文段的IP数据报到达服务器主机，服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向客户机发送SYNACK报文段。（在完成三次握手的第三步之前分配这些缓存和变量，使得TCP易于收到SYN泛洪的拒绝服务攻击）。该报文段也不包含应用层数据。但在报文段首部：SYN比特被置为1，首部的确认号字段被置为client_isn + 1，序号字段被指为服务器自己选择的server_isn。

第三步：在收到SYNACK报文段之后，客户机也要给该连接分配缓存和变量。客户机还会向服务器发送另外一个报文段，该报文段对服务器的SYNACK进行了确认。该报文段的SYN被置为0，确认好字段被置为server_isn + 1。

## TCP四次挥手

假设客户端打算关闭连接。

第一步：客户机TCP向服务器进程发送一个特殊的TCP报文段，该报文段首部的FIN比特被置为1

第二步：服务器收到客户机的报文段后，向客户机回送一个确认报文段

第三步：服务器发送其终止报文段，其FIN比特被置为1.

第四步：该客户机对服务器的终止报文段进行确认。

## TCP三次握手，四次挥手中服务器，客户机状态图

客户机状态图

![](https://raw.githubusercontent.com/roger1245/ImgBed/master/img/%E5%AE%A2%E6%88%B7%E6%9C%BA%E7%8A%B6%E6%80%81%E5%9B%BE.png)

服务器状态图

![](https://raw.githubusercontent.com/roger1245/ImgBed/master/img/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81%E5%9B%BE.png)



## 问：为什么是三次握手不是两次？

为什么TCP是三次握手，其实就是要证明2次太少，4次又没必要

TCP是可靠传输协议，三次握手的本质其实就是要确定客户端和服务端，它们的发送和接收能力是没问题的

第一次握手证明了客户端的发送能力是没有问题的

第二次握手证明了服务端的接受能力和发送能力是没有问题的

第三次握手证明了客户端的接收能力是没有问题的。

除此之外，TCP需要seq序列号来做可靠重传或者接收，从而避免连接复用时无法分辨出seq是延迟或者旧连接的seq，因此需要三次握手来约定双方的ISN

## 问：为什么是四次挥手而不是三次？

因为TCP是全双工通信的

1. 第一次挥手：当主动方发送断开连接的请求（FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。
2. 第二次挥手：被动方此时有可能还有相应的数据报文需要发送，因此需要像发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即第一次挥手？）
3. 第三次挥手：被动方在处理完数据报文后，便给主动方发送FIN报文；这样可以保证数据通信可靠的完成。此时被动方进入LAST_ACK阶段
4. 第四次挥手：如果主动方及时发送ACK报文段进行连接中断的确认，此时被动方就直接释放连接，进入可用状态。

ack是为了让对方闭嘴。

1）A不停的说，我想结束

2）B收到后，还有数据没有处理完，就发ack让A闭嘴。等我处理完再说。

3）B终于处理完了，不停地对A说，满足你，你结束吧

4）A知道B要结束了，给B说，可以闭嘴了，我结束。B收到结束，不再发送确认，进入关闭态。





参考：

[掘金-TCP握手为什么是三次](https://juejin.im/post/5e4ca85ef265da572e4f2227)

[知乎-TCP为什么是四次挥手，不是三次](https://www.zhihu.com/question/63264012)

《计算机网络自顶向下》